"""Change actor to group in boost

Revision ID: cbfd1a9fc201
Revises: e85d4e547af4
Create Date: 2023-05-27 21:20:46.003497

"""
from alembic import op
import sqlalchemy as sa
import sqlmodel
import os
import yaml

# revision identifiers, used by Alembic.
revision = 'cbfd1a9fc201'
down_revision = 'e85d4e547af4'
branch_labels = None
depends_on = None

def get_group_name(actor_id, connection):
    return


def upgrade() -> None:
    # Load config to get domain name
    DIR = os.path.dirname(__file__)
    CONFIG_PATH = os.path.join(DIR, "..", "..", "app", "config.yml")

    def get_config():
        with open(CONFIG_PATH) as f:
            return yaml.load(f, Loader=yaml.FullLoader)
        return

    config = get_config()
    SERVER_DOMAIN = config["main"]["server_url"]

    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('boosts', sa.Column('group_id', sa.Integer(), nullable=True))
    op.drop_constraint('boosts_actor_id_fkey', 'boosts', type_='foreignkey')
    op.create_foreign_key(None, 'boosts', 'groups', ['group_id'], ['id'])
    
    op.alter_column('groups', 'creator_id',
               existing_type=sa.INTEGER(),
               nullable=True)

    # Create tables so we can queue them
    t_group = sa.Table(
        'groups',
        sa.MetaData(),
        sa.Column('id', sa.Integer()),
        sa.Column('name', sa.Integer())
        )


    t_boosts = sa.Table(
        'boosts',
        sa.MetaData(),
        sa.Column('id', sa.Integer()),
        sa.Column('group_id', sa.Integer()), # Old column.
        sa.Column('actor_id', sa.Integer()), # new column.
        )

    t_actors = sa.Table(
        'actors',
        sa.MetaData(),
        sa.Column('id', sa.Integer()),
        sa.Column('name', sa.Integer()), # Old column.
        )
    
    # Use Alchemy's connection and transaction to noodle over the data.
    connection = op.get_bind()
    
    # Create a dict that convertes between actor ids and group ids
    actor_id_to_group_id = {}

    results = connection.execute(sa.select([
        t_group.c.id,
        t_group.c.name,
        ])).fetchall()

    for id_, name in results:
        group_actor = f"{name}@{SERVER_DOMAIN}"

        actor_results = connection.execute(sa.select([
        t_actors.c.id,
        t_actors.c.name,
        ]).where(t_actors.c.name == group_actor)).first()

        if actor_results is not None:
            actor_id_to_group_id[actor_results.id] = id_


    results = connection.execute(sa.select([
    t_boosts.c.id,
    # t_boosts.c.group_id,
    t_boosts.c.actor_id,
    ])).fetchall()

    for id_, actor_id in results:
        u = sa.update(t_boosts).values({"group_id": actor_id_to_group_id.get(actor_id, None)}).where(t_boosts.c.id == id_)
        connection.execute(u)

    op.drop_column('boosts', 'actor_id')


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.alter_column('groups', 'creator_id',
               existing_type=sa.INTEGER(),
               nullable=False)
    op.add_column('boosts', sa.Column('actor_id', sa.INTEGER(), autoincrement=False, nullable=True))


    # Load config to get domain name
    DIR = os.path.dirname(__file__)
    CONFIG_PATH = os.path.join(DIR, "..", "..", "app", "config.yml")

    def get_config():
        with open(CONFIG_PATH) as f:
            return yaml.load(f, Loader=yaml.FullLoader)
        return

    config = get_config()
    SERVER_DOMAIN = config["main"]["server_url"]

    # ### commands auto generated by Alembic - please adjust! ###
    # op.add_column('boosts', sa.Column('actor_id', sa.Integer(), nullable=True))
    # op.drop_constraint('boosts_actor_id_fkey', 'boosts', type_='foreignkey')
    op.create_foreign_key(None, 'boosts', 'groups', ['group_id'], ['id'])
    
    op.alter_column('groups', 'creator_id',
               existing_type=sa.INTEGER(),
               nullable=True)

    # Create tables so we can queue them
    t_group = sa.Table(
        'groups',
        sa.MetaData(),
        sa.Column('id', sa.Integer()),
        sa.Column('name', sa.Integer())
        )


    t_boosts = sa.Table(
        'boosts',
        sa.MetaData(),
        sa.Column('id', sa.Integer()),
        sa.Column('group_id', sa.Integer()), # Old column.
        sa.Column('actor_id', sa.Integer()), # new column.
        )

    t_actors = sa.Table(
        'actors',
        sa.MetaData(),
        sa.Column('id', sa.Integer()),
        sa.Column('name', sa.Integer()), # Old column.
        )
    
    # Use Alchemy's connection and transaction to noodle over the data.
    connection = op.get_bind()
    
    # Create a dict that convertes between actor ids and group ids
    group_id_to_actor_id = {}

    results = connection.execute(sa.select([
        t_group.c.id,
        t_group.c.name,
        ])).fetchall()

    for id_, name in results:
        group_actor = f"{name}@{SERVER_DOMAIN}"

        actor_results = connection.execute(sa.select([
        t_actors.c.id,
        t_actors.c.name,
        ]).where(t_actors.c.name == group_actor)).first()

        if actor_results is not None:
            group_id_to_actor_id[id_] = actor_results.id


    results = connection.execute(sa.select([
    t_boosts.c.id,
    t_boosts.c.group_id,
    # t_boosts.c.actor_id,
    ])).fetchall()

    for id_, group_id in results:
        u = sa.update(t_boosts).values({"actor_id": group_id_to_actor_id.get(group_id, None)}).where(t_boosts.c.id == id_)
        connection.execute(u)

    # op.drop_constraint(None, 'boosts', type_='foreignkey')
    op.create_foreign_key('boosts_actor_id_fkey', 'boosts', 'actors', ['actor_id'], ['id'])
    op.drop_column('boosts', 'group_id')
    # ### end Alembic commands ###
