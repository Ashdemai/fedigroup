"""change actor to group in note

Revision ID: ffce437ee1f4
Revises: cbfd1a9fc201
Create Date: 2023-05-31 18:20:15.637875

"""
from alembic import op
import sqlalchemy as sa
import sqlmodel
from app.common import get_config


# revision identifiers, used by Alembic.
revision = 'ffce437ee1f4'
down_revision = 'cbfd1a9fc201'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('notes', sa.Column('group_id', sa.Integer(), nullable=True))
    op.drop_constraint('notes_actor_id_fkey', 'notes', type_='foreignkey')
    op.create_foreign_key(None, 'notes', 'groups', ['group_id'], ['id'])


    config = get_config()
    SERVER_DOMAIN = config["main"]["server_url"]

    op.alter_column('groups', 'creator_id',
               existing_type=sa.INTEGER(),
               nullable=True)

    # Create tables so we can queue them
    t_group = sa.Table(
        'groups',
        sa.MetaData(),
        sa.Column('id', sa.Integer()),
        sa.Column('name', sa.Integer())
        )


    t_notes = sa.Table(
        'notes',
        sa.MetaData(),
        sa.Column('id', sa.Integer()),
        sa.Column('group_id', sa.Integer()), # Old column.
        sa.Column('actor_id', sa.Integer()), # new column.
        )

    t_actors = sa.Table(
        'actors',
        sa.MetaData(),
        sa.Column('id', sa.Integer()),
        sa.Column('name', sa.Integer()), # Old column.
        )
    
    # Use Alchemy's connection and transaction to noodle over the data.
    connection = op.get_bind()
    
    # Create a dict that convertes between actor ids and group ids
    actor_id_to_group_id = {}

    results = connection.execute(sa.select([
        t_group.c.id,
        t_group.c.name,
        ])).fetchall()

    for id_, name in results:
        group_actor = f"{name}@{SERVER_DOMAIN}"

        actor_results = connection.execute(sa.select([
        t_actors.c.id,
        t_actors.c.name,
        ]).where(t_actors.c.name == group_actor)).first()

        if actor_results is not None:
            actor_id_to_group_id[actor_results.id] = id_


    results = connection.execute(sa.select([
    t_notes.c.id,
    # t_notes.c.group_id,
    t_notes.c.actor_id,
    ])).fetchall()

    for id_, actor_id in results:
        u = sa.update(t_notes).values({"group_id": actor_id_to_group_id.get(actor_id, None)}).where(t_notes.c.id == id_)
        connection.execute(u)

    op.drop_column('notes', 'actor_id')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('notes', sa.Column('actor_id', sa.INTEGER(), autoincrement=False, nullable=True))
    # op.drop_constraint(None, 'notes', type_='foreignkey')


    config = get_config()
    SERVER_DOMAIN = config["main"]["server_url"]

    # ### commands auto generated by Alembic - please adjust! ###
    # op.add_column('boosts', sa.Column('actor_id', sa.Integer(), nullable=True))
    # op.drop_constraint('boosts_actor_id_fkey', 'boosts', type_='foreignkey')
    op.create_foreign_key(None, 'boosts', 'groups', ['group_id'], ['id'])
    
    op.alter_column('groups', 'creator_id',
               existing_type=sa.INTEGER(),
               nullable=True)

    # Create tables so we can queue them
    t_group = sa.Table(
        'groups',
        sa.MetaData(),
        sa.Column('id', sa.Integer()),
        sa.Column('name', sa.Integer())
        )


    t_notes = sa.Table(
        'notes',
        sa.MetaData(),
        sa.Column('id', sa.Integer()),
        sa.Column('group_id', sa.Integer()), # Old column.
        sa.Column('actor_id', sa.Integer()), # new column.
        )

    t_actors = sa.Table(
        'actors',
        sa.MetaData(),
        sa.Column('id', sa.Integer()),
        sa.Column('name', sa.Integer()), # Old column.
        )
    
    # Use Alchemy's connection and transaction to noodle over the data.
    connection = op.get_bind()
    
    # Create a dict that convertes between actor ids and group ids
    group_id_to_actor_id = {}

    results = connection.execute(sa.select([
        t_group.c.id,
        t_group.c.name,
        ])).fetchall()

    for id_, name in results:
        group_actor = f"{name}@{SERVER_DOMAIN}"

        actor_results = connection.execute(sa.select([
        t_actors.c.id,
        t_actors.c.name,
        ]).where(t_actors.c.name == group_actor)).first()

        if actor_results is not None:
            group_id_to_actor_id[id_] = actor_results.id


    results = connection.execute(sa.select([
    t_notes.c.id,
    t_notes.c.group_id,
    # t_notes.c.actor_id,
    ])).fetchall()

    for id_, group_id in results:
        u = sa.update(t_notes).values({"actor_id": group_id_to_actor_id.get(group_id, None)}).where(t_notes.c.id == id_)
        connection.execute(u)


    op.create_foreign_key('notes_actor_id_fkey', 'notes', 'actors', ['actor_id'], ['id'])
    op.drop_column('notes', 'group_id')
    # ### end Alembic commands ###
